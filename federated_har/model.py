# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Model.ipynb.

# %% auto 0
__all__ = ['create_model', 'train', 'test']

# %% ../nbs/Model.ipynb 2
import torch
from torchvision.models.video import swin3d_t, Swin3D_T_Weights
from torch import nn

import sys
sys.path.append('..')

from .datasets import *

# %% ../nbs/Model.ipynb 11
def create_model(num_out):
    """
    Loads pretrained model and freezes all layers except new custom head layer

    Args:
        num_out (int): number of classes to output

    Returns: 
        Swin3D transformer Small Pytorch model
    """
    model = swin3d_t(weights=Swin3D_T_Weights.DEFAULT)
    for param in model.parameters():
        param.requires_grad = False

    num_ftrs = model.head.in_features
    model.head = nn.Linear(in_features=num_ftrs, out_features=num_out)
    return model

# %% ../nbs/Model.ipynb 13
def train(net, trainloader, optimizer, epochs):
    """Train the network on the training set."""
    criterion = torch.nn.CrossEntropyLoss()
    net.train()
    for _ in range(epochs):
        for images, labels in trainloader:
            optimizer.zero_grad()
            preds = net(images)
            loss = criterion(preds, labels)
            loss.backward()
            optimizer.step()
    return net

# %% ../nbs/Model.ipynb 14
def test(net, testloader, device='cpu'):
    """Validate the network on the entire test set."""
    net.to(device)
    criterion = torch.nn.CrossEntropyLoss()
    correct, loss = 0, 0.0
    net.eval()
    with torch.no_grad():
        for images, labels in testloader:
            images, labels = images.to(device), labels.to(device)
            outputs = net(images)
            loss += criterion(outputs, labels).item()
            _, predicted = torch.max(outputs.data, 1)
            correct += (predicted == labels).sum().item()
    accuracy = correct / len(testloader.dataset)
    return loss, accuracy
